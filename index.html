<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ぶりゲーム（石川の出世魚）- プロトタイプ</title>
  <style>
	:root {
	  --bg:#0b132b; /* 夜の日本海っぽい濃紺 */
	  --panel:#1c2541;
	  --accent:#5bc0be;
	  --text:#e6f3f3;
	  --danger:#f45b69;
	}
	html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b132b 0%,#10203f 60%,#0b132b 100%);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,'Noto Sans JP','Hiragino Kaku Gothic ProN','Meiryo',sans-serif;color:var(--text)}
	.wrap{display:grid;grid-template-columns:320px 1fr;gap:16px;max-width:1100px;margin:16px auto;padding:8px}
	.left{background:var(--panel);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.3)}
	.title{font-weight:800;font-size:20px;margin-bottom:8px;letter-spacing:.02em}
	.subtitle{opacity:.8;font-size:12px;margin-bottom:16px}
	.hud{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:12px}
	.card{background:#111c33;border:1px solid #23345f;border-radius:12px;padding:10px}
	.big{font-size:24px;font-weight:700}
	canvas{background:linear-gradient(180deg,rgba(91,192,190,.08),rgba(91,192,190,.02));display:block;border-radius:16px;border:1px solid #25406b;box-shadow:0 10px 30px rgba(0,0,0,.35)}
	/* スマホ対応 */
	canvas{width:100%;height:auto;touch-action:none}
	@media (max-width: 900px){
	  .wrap{grid-template-columns:1fr}
	}
	.controls{display:grid;gap:8px;margin-top:8px}
	.controls button{background:var(--accent);color:#052a2a;border:none;border-radius:12px;padding:10px 12px;font-weight:700;cursor:pointer}
	.controls button.secondary{background:#203456;color:#d7e9ff}
	.levels{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
	.pill{display:flex;align-items:center;gap:8px;background:#0f1d35;border:1px solid #243a69;border-radius:999px;padding:6px 10px;font-size:12px}
	.dot{width:14px;height:14px;border-radius:50%}
	.thumb{width:24px;height:24px;border-radius:50%;object-fit:cover;background:#0b132b;border:1px solid #223c6a}
	.kbd{display:inline-block;background:#0e1a31;border:1px solid #284776;padding:2px 6px;border-radius:6px;font-weight:700}
	.gameover{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(7,13,26,.75);backdrop-filter: blur(4px);}
	.dialog{background:var(--panel);border:1px solid #2c4276;border-radius:16px;max-width:520px;padding:18px;box-shadow:0 20px 60px rgba(0,0,0,.6)}
	.dialog h2{margin:0 0 8px}
	.dialog p{opacity:.9}
	.dialog .row{display:flex;gap:8px;margin-top:12px}
	.dialog button{flex:1}
	.blink{animation: bl 1s infinite}
	@keyframes bl{50%{opacity:.35}}
  </style>
</head>
<body>
  <div class="wrap">
	<div class="left">
	  <div class="title">ぶりゲーム（ご当地版）</div>
	  <div class="subtitle">石川の出世魚：<b>魚卵 → 稚魚 → こぞくら → ふくらぎ → がんど → ぶり → 刺身 → 寿司 → ぶり大根 → 鰤しゃぶ</b></div>

	  <div class="hud">
		<div class="card">
		  スコア<br><span id="score" class="big">0</span>
		</div>
		<div class="card">
		  次に落ちる：<br>
		  <div id="nextBox" style="display:flex;align-items:center;gap:8px;margin-top:4px"></div>
		</div>
	  </div>

	  <div class="controls">
		<div>操作：PCは <span class="kbd">←</span><span class="kbd">→</span> で移動 / <span class="kbd">スペース</span> でドロップ / <span class="kbd">R</span> でリセット。スマホは「画面ドラッグで移動・離してドロップ」。</div>
		<button id="dropBtn" class="blink">スペースでドロップ</button>
		<div class="levels" id="legend"></div>
		<button id="resetBtn" class="secondary">リセット</button>
	  </div>
	</div>

	<div>
	  <canvas id="game" width="720" height="960" aria-label="ゲームフィールド"></canvas>
	</div>
  </div>

  <div class="gameover" id="gameover">
	<div class="dialog">
	  <h2>ゲームオーバー</h2>
	  <p>海があふれました…！ スコア：<b id="finalScore">0</b></p>
	  <div class="row">
		<button id="again">もう一度</button>
		<button id="quit" class="secondary">閉じる</button>
	  </div>
	</div>
  </div>

  <script>
  // レベル画像プリロード（LEVELS.length）
  const IMAGES = [];
  function preloadImages(){
    return Promise.all(
      Array.from({length: LEVELS.length}, (_,i)=> new Promise(resolve=>{
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = ()=>{ IMAGES[i]=img; resolve(); };
        img.onerror = ()=>{ IMAGES[i]=null; resolve(); };
        img.src = `img/${i}.png`;
      }))
    );
  }

  // ========== ゲーム定義 ==========
  const LEVELS = [
	{ name: '魚卵',   color: '#f8d568', r: 24, score: 1 },
	{ name: '稚魚',   color: '#9be1fa', r: 28, score: 2 },
	{ name: 'こぞくら', color: '#6ed6a1', r: 34, score: 4 },
	{ name: 'ふくらぎ', color: '#3fd0c9', r: 44, score: 8 },
	{ name: 'がんど',  color: '#3b82f6', r: 58, score: 16 },
	{ name: 'ぶり',   color: '#c084fc', r: 78, score: 64 },
	{ name: '刺身',   color: '#f472b6', r: 84, score: 96, isDish:true },
	{ name: '寿司',   color: '#60a5fa', r: 88, score: 128, isDish:true },
	{ name: 'ぶり大根', color: '#ff9f68', r: 88, score: 160, isDish:true },
	{ name: '鰤しゃぶ', color: '#ffd166', r: 88, score: 192, isDish:true },
  ];

  // 出現確率（序盤は低レベルが多め）
  function rollLevel() {
	const bag = [0,0,0, 1,1, 2]; // 低レベル寄り
	return bag[Math.floor(Math.random()*bag.length)];
  }

  // ========== 物理 & ゲーム状態 ==========
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  const world = {
	gravity: 0.45,
	air: 0.995, // 空気抵抗
	bounce: 0.55,
	friction: 0.98,
	left: 120, right: W-120, top: 60, bottom: H-40
  };

  let balls = [];
  let score = 0;
  let nextLevel = rollLevel();
  let current = null; // まだ落としていないボール
  let gameOver = false;

  const uiScore = document.getElementById('score');
  const nextBox = document.getElementById('nextBox');
  const legendBox = document.getElementById('legend');

  // レジェンド描画（画像が無ければ色ドットにフォールバック）
  LEVELS.forEach((lv,i)=>{
    const div = document.createElement('div');
    div.className='pill';
    const img = new Image();
    img.className = 'thumb';
    img.alt = lv.name;
    img.src = `img/${i}.png`;
    img.onerror = ()=>{
      img.remove();
      const dot = document.createElement('span');
      dot.className = 'dot';
      dot.style.background = lv.color;
      div.insertBefore(dot, div.firstChild);
    };
    div.appendChild(img);
    const label = document.createElement('span');
    label.textContent = `${i+1}. ${lv.name}`;
    div.appendChild(label);
    legendBox.appendChild(div);
  });

  function renderNext() {
    nextBox.innerHTML = '';
    const lv = LEVELS[nextLevel];
    const img = new Image();
    img.className = 'thumb';
    img.alt = lv.name;
    img.src = `img/${nextLevel}.png`;
    img.onerror = ()=>{
      img.remove();
      const dot = document.createElement('span');
      dot.className = 'dot';
      dot.style.background = lv.color;
      nextBox.insertBefore(dot, nextBox.firstChild);
    };
    const label = document.createElement('span');
    label.textContent = lv.name;
    nextBox.appendChild(img);
    nextBox.appendChild(label);
  }
  renderNext();

  function spawnHeld() {
	if (current) return;
	const lv = LEVELS[nextLevel];
	current = {
	  x: (world.left + world.right)/2,
	  y: world.top + lv.r + 4,
	  vx: 0, vy: 0,
	  r: lv.r,
	  level: nextLevel,
	  isHeld: true,
	  id: crypto.randomUUID(),
	};
	nextLevel = rollLevel();
	renderNext();
  }

  function dropHeld() {
	if (!current || gameOver) return;
	current.isHeld = false;
	balls.push(current);
	current = null;
  }

  // ========== 入力 ==========
  const KEYS = { left:false, right:false };
  window.addEventListener('keydown', e=>{
	if (e.code==='ArrowLeft' || e.code==='KeyA') KEYS.left=true;
	if (e.code==='ArrowRight'|| e.code==='KeyD') KEYS.right=true;
	if (e.code==='Space') dropHeld();
	if (e.code==='KeyR') hardReset();
  });
  window.addEventListener('keyup', e=>{
	if (e.code==='ArrowLeft' || e.code==='KeyA') KEYS.left=false;
	if (e.code==='ArrowRight'|| e.code==='KeyD') KEYS.right=false;
  });
  document.getElementById('dropBtn').onclick = dropHeld;
  document.getElementById('resetBtn').onclick = hardReset;

  // スマホ/タッチ・ポインタ操作
  let pointerActive = false;
  function clientToCanvasX(clientX){
    const rect = canvas.getBoundingClientRect();
    return (clientX - rect.left) * (canvas.width / rect.width);
  }
  function setCurrentXFromClientX(clientX){
    if (!current) return;
    const x = clientToCanvasX(clientX);
    current.x = clamp(x, world.left+current.r, world.right-current.r);
  }
  canvas.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    pointerActive = true;
    setCurrentXFromClientX(e.clientX);
  });
  canvas.addEventListener('pointermove', (e)=>{
    if (!pointerActive) return;
    setCurrentXFromClientX(e.clientX);
  });
  canvas.addEventListener('pointerup', (e)=>{
    if (!pointerActive) return;
    pointerActive = false;
    dropHeld();
  });

  // ========== ユーティリティ ==========
  function circleOverlap(a,b){
	const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy);
	return d < a.r + b.r;
  }
  // 少し離れていても「触れた」とみなす緩和判定（合体を確実化）
  function closeEnough(a,b){
    const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy);
    return d <= a.r + b.r + 0.8; // 0.8px のマージン
  }

  function resolveCircle(a,b){
    const dx=b.x-a.x, dy=b.y-a.y; let d=Math.hypot(dx,dy);
    if (d===0) { d=0.01; }
    const overlap = a.r + b.r - d;
    if (overlap>0){
      const nx = dx/d, ny = dy/d;
      // 位置を押し出す
      const m1 = a.r, m2 = b.r; // 簡易質量は見た目サイズベースのまま
      const total = m1+m2;
      a.x -= nx * overlap * (m2/total);
      a.y -= ny * overlap * (m2/total);
      b.x += nx * overlap * (m1/total);
      b.y += ny * overlap * (m1/total);
      // 反発（簡易）
      const relVx = b.vx - a.vx;
      const relVy = b.vy - a.vy;
      const vn = relVx*nx + relVy*ny;
      if (vn<0){
        const imp = -(1+world.bounce)*vn/(1/m1+1/m2);
        const ix = imp*nx, iy = imp*ny;
        a.vx -= ix/m1; a.vy -= iy/m1;
        b.vx += ix/m2; b.vy += iy/m2;
      }
    }
  }

  // ピクセル分離・判定は使用しません（バブル円で物理解決）

  function clamp(val,min,max){return Math.max(min,Math.min(max,val));}

  // ========== メインループ ==========
  let last = performance.now();
  function tick(now){
	const dt = Math.min(33, now-last); // ms（未使用でも将来のため残す）
	last = now;

	// 保持中のボールを左右移動
  if (current){
      const speed = 6;
      if (KEYS.left) current.x -= speed;
      if (KEYS.right) current.x += speed;
      current.x = clamp(current.x, world.left+current.r, world.right-current.r);
  } else if (!gameOver) {
	  // 新しいボールを供給
	  spawnHeld();
	}

	// 物理更新
  for (const b of balls){
    // 重力
    b.vy += world.gravity;
	  // 抵抗
	  b.vx *= world.air;
	  b.vy *= world.air;
	  // 位置更新
	  b.x += b.vx;
	  b.y += b.vy;

    // 壁との衝突（バブル半径で判定）
    if (b.x - b.r < world.left){ b.x = world.left + b.r; b.vx = -b.vx * world.bounce; }
    if (b.x + b.r > world.right){ b.x = world.right - b.r; b.vx = -b.vx * world.bounce; }
    if (b.y + b.r > world.bottom){ b.y = world.bottom - b.r; b.vy = -Math.abs(b.vy) * world.bounce; b.vx *= world.friction; }
    // 上に突き抜けたら終了条件チェック
    if (b.y - b.r < world.top - 8){
      triggerGameOver();
    }
  }

	// 円同士の衝突解決 & マージ
  // 1) 位置解決 + 反発（円ベース）
  for (let i=0;i<balls.length;i++){
    for (let j=i+1;j<balls.length;j++){
      resolveCircle(balls[i], balls[j]);
    }
  }
  // 2) マージ（必ず触れたら合体）
  outer: for (let i=0;i<balls.length;i++){
    for (let j=i+1;j<balls.length;j++){
      const a=balls[i], b=balls[j];
      if (!closeEnough(a,b)) continue; // バブル同士の接触

      // 同レベルのみ合体（異レベルは何もしない）
      if (a.level===b.level){
        const nx=(a.x+b.x)/2, ny=(a.y+b.y)/2;
        // 0〜4: 通常の出世
        if (a.level < 5){
          const nl = a.level+1;
          const nb = { x:nx, y:ny, vx:(a.vx+b.vx)/2, vy:-6, r:LEVELS[nl].r, level:nl, id:crypto.randomUUID() };
          score += LEVELS[a.level].score;
          balls.splice(j,1); balls.splice(i,1);
          balls.push(nb);
          break outer;
        }
        // 5: ぶり → 6: 刺身
        if (a.level === 5){
          const nl = 6;
          const nb = { x:nx, y:ny, vx:(a.vx+b.vx)/2, vy:-6, r:LEVELS[nl].r, level:nl, id:crypto.randomUUID() };
          score += LEVELS[a.level].score;
          balls.splice(j,1); balls.splice(i,1);
          balls.push(nb);
          break outer;
        }
        // 6〜8: 刺身→寿司→ぶり大根→鰤しゃぶ
        if (a.level >= 6 && a.level <= 8){
          const nl = a.level + 1;
          const nb = { x:nx, y:ny, vx:(a.vx+b.vx)/2, vy:-6, r:LEVELS[nl].r, level:nl, id:crypto.randomUUID() };
          score += LEVELS[a.level].score;
          balls.splice(j,1); balls.splice(i,1);
          balls.push(nb);
          break outer;
        }
        // 9: 鰤しゃぶ → 合体で消滅（ボーナス）
        if (a.level === 9){
          balls.splice(j,1); balls.splice(i,1);
          score += LEVELS[a.level].score;
          break outer;
        }
      }
    }
  }

	draw();

	// スコア表示
	uiScore.textContent = score.toLocaleString();

	if (!gameOver) requestAnimationFrame(tick);
  }

  function draw(){
	// 背景（海 + ガイド）
	ctx.clearRect(0,0,W,H);
	// 境界枠
	ctx.save();
	ctx.strokeStyle = 'rgba(160,190,255,.35)';
	ctx.lineWidth = 2;
	ctx.beginPath();
	ctx.moveTo(world.left, world.top);
	ctx.lineTo(world.left, world.bottom);
	ctx.lineTo(world.right, world.bottom);
	ctx.lineTo(world.right, world.top);
	ctx.closePath();
	ctx.stroke();

	// 海中の泡っぽい粒子（軽い装飾）
	for (let i=0;i<16;i++){
	  const x = world.left + ((i*137)% (world.right-world.left));
	  const y = (performance.now()/30 + i*60) % (world.bottom-world.top) + world.top;
	  ctx.globalAlpha = 0.06;
	  ctx.beginPath(); ctx.arc(x,y, 8 + (i%3)*3, 0, Math.PI*2); ctx.fillStyle = '#9bd1ff'; ctx.fill();
	  ctx.globalAlpha = 1;
	}

	// 保持中の影
	if (current){
	  ctx.globalAlpha = 0.2;
	  drawBall({...current});
	  ctx.globalAlpha = 1;
	  // 上部のドロップレーン
	  ctx.fillStyle='rgba(200,230,255,.08)';
	  ctx.fillRect(world.left, world.top, world.right-world.left, 60);
	}

	// ボール
	for (const b of balls) drawBall(b);

	ctx.restore();
  }

  function drawBall(b){
    const lv = LEVELS[b.level];
    const img = IMAGES[b.level];
    const r = b.r;
    const size = r * 2;

    // 中身（画像）を円でクリップして描画
    ctx.save();
    ctx.beginPath(); ctx.arc(b.x, b.y, r, 0, Math.PI*2); ctx.clip();
    if (img){
      ctx.drawImage(img, b.x - r, b.y - r, size, size);
    } else {
      // フォールバック（円グラデ）
      const g = ctx.createRadialGradient(b.x-r*0.4, b.y-r*0.6, r*0.2, b.x, b.y, r);
      g.addColorStop(0, '#ffffff');
      g.addColorStop(0.15, lv.color);
      g.addColorStop(1, shade(lv.color,-0.35));
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(b.x,b.y,r,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    // バブルっぽい縁・ハイライト
    ctx.save();
    // 外枠
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(b.x, b.y, r-1, 0, Math.PI*2); ctx.stroke();
    // 上部ハイライト
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = Math.max(1.5, r*0.06);
    ctx.arc(b.x - r*0.25, b.y - r*0.35, r*0.7, -Math.PI*0.2, Math.PI*0.5);
    ctx.stroke();
    // 右下の薄い反射
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = Math.max(1, r*0.04);
    ctx.arc(b.x + r*0.25, b.y + r*0.25, r*0.7, Math.PI*0.8, Math.PI*1.2);
    ctx.stroke();
    ctx.restore();
  }

  function shade(hex, lum){
	// #rrggbb → 明暗調整
	hex = String(hex).replace(/[^0-9a-f]/gi,'');
	if (hex.length<6) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
	let rgb = '#';
	for (let i=0;i<3;i++){
	  let c = parseInt(hex.substr(i*2,2),16);
	  c = Math.round(Math.min(Math.max(0, c + (c*lum)), 255));
	  rgb += ('00'+c.toString(16)).substr(-2);
	}
	return rgb;
  }

  function triggerGameOver(){
	if (gameOver) return;
	gameOver = true;
	document.getElementById('finalScore').textContent = score.toLocaleString();
	document.getElementById('gameover').style.display = 'flex';
  }

  function hardReset(){
	balls = [];
	score = 0;
	nextLevel = rollLevel();
	renderNext();
	current = null;
	gameOver = false;
	document.getElementById('gameover').style.display = 'none';
	last = performance.now();
	spawnHeld();
	requestAnimationFrame(tick);
  }

  document.getElementById('again').onclick = hardReset;
  document.getElementById('quit').onclick = ()=>{
	document.getElementById('gameover').style.display = 'none';
  };

  // 初期化（画像ロード後に開始）
  preloadImages().then(()=>{
    hardReset();
  });

  </script>
</body>
</html>
